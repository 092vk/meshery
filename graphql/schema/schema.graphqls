#? Do we want these workloads and things to be independent of service mesh.
#! Views are generic - agnostic to the service mesh

# VIEW 1 ######################################################################################
## Service Mesh View
### show all the workloads 
### show a workload(application) as a single entity - box
### Other things to show - ingress, virtual services.
# VIEW 2 ######################################################################################
## Single Workload View
### Show what is there in a workload
### Other things to show - service, destination rules.

type Query {
    mapEdges(ID:MapEdgeIdentifier): [MapEdge]
    mapNodes(ID:MapNodeIdentifier): [MapNode]
}

input MapNodeIdentifier {
    view: View
    # what MapNodes should be there in the frontend
    # kind: String
    # parentKind: String
    # id: ID
    # parentKind: String # services
    # parentID: ID
}

input MapEdgeIdentifier {
    view: View
    # kind: String
    # fromKind: String
    # toKind: String
    # fromNode: ID
    # toNode:ID
    # metadata
    # details
}

enum View {
    SERVICEMESHVIEW
    WORKLOADVIEW
}

type MapNode {
    id: ID
    parentID: ID
    metadata: MetaData
    details: String # sol - json String - convert to json object in the frontend.
}

type MetaData {
    name: String
    namespace: String
    nodeType: String
    uid: ID
}

type MapEdge {
    fromID: ID
    toID: ID
    # metadata: MapEdgeMetadata
    # value: int
}

# type MapEdgeMetadata {
    
# }

# Defined scalar that will correspond to the following go types
# In relay they will be converted to any type
scalar Time # go type -> time.Time
# scalar Map # go type -> map[String]interface{}

# we cannot name MapNode as Node, it is not allowed in the relay specification